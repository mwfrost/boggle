<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous">
    </script>
    <!-- Internal styles -->
    <style>
        #lettergrid {
            font-family: 'DejaVu Sans Mono', monospace;
            font-size: 4em;
            line-height: 1em;
        }
    </style>

    <title>Boggle Graph</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>
<script type="text/javascript">
    $(document).ready(
        function () {
            //constants
            const GRID_WIDTH = 2;
            const GRID_HEIGHT = 2;
            const USE_QU_SQUARE = false;
            const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

            // style the objects according to the constants
            $('#lettergrid').attr('cols', GRID_WIDTH);
            $('#lettergrid').attr('rows', GRID_HEIGHT);

            // initialize the words to search for
            var wordlist = "am,be,do,is,as,an,at,by,in,no,of,on,so,to,up,he,it,me,us,we".toUpperCase().split(",");
            var maxLetterCount = Math.max(...(wordlist.map(el => el.length)));
            var node = document.createTextNode(wordlist.join(", "));

            $('#wordbox').html(wordlist.join(","));

            $('#wordbox').on('input', function () {
                newlist = $('#wordbox').val();
                wordlist = newlist.toUpperCase().split(",");
                var maxLetterCount = Math.max(...(wordlist.map(el => el.length)));
                console.log(maxLetterCount);
            });


            // functions
            class LetterGrid {
                // using a constructor instead of just declaring the function
                // allows repeated reshuffling
                constructor() {
                    // generate an array of strings whose keys reflect 
                    // their x,y coordinates
                    var letters = [];
                    var letterCount = GRID_HEIGHT * GRID_WIDTH;
                    for (var i = 0; i < letterCount; i++) {
                        letters.push(
                            ALPHABET.charAt(Math.floor(Math.random() *
                                ALPHABET.length))
                        );
                    }
                    letters[0] = "A";
                    letters[1] = "M";
                    this.letters = letters;
                    this.foundWords = [];
                    this.visitedPaths = [];
                }
            }

            LetterGrid.prototype.cells_to_string = function (cells) {
                letters = [];
                cells.forEach(cell => letters.push(this.letters[cell]));
                return letters.join("");
            }

            function dfs(start, visited = new Set()) {
                visited.add(start);
                const neighbors = adjacencyGraph.get(start);

                for (const neighbor of neighbors) {
                    pathString = letterGrid.cells_to_string(visited);
                    console.log(pathString);
                    if (wordlist.includes(pathString)) {
                        console.log(pathString + " found");
                        letterGrid.foundWords.push(pathString);
                        $('#found-words').html(letterGrid.foundWords.join(","));
                    }

                    if (!visited.has(neighbor)) {
                        // keep pursuing the chain of first-neighbor adjacencies
                        dfs(neighbor, visited);
                    }

                }

            }
            // Recursively visit each node's first adjacent node

            LetterGrid.prototype.search_deep_path = function (path) {
                // TODO: clean up this scoping issue
                var maxLetterCount = Math.max(...(wordlist.map(el => el.length)));

                // See if the path argument matches a word before appending any nodes
                let pathstring = this.cells_to_string(path);
                console.log("Checking for string '" + pathstring + "'");
                found = wordlist.includes(pathstring);
                if (found) {
                    console.log(pathstring + " found");
                    this.foundWords.push(pathstring);
                }
                // record that the path was visited
                this.visitedPaths.push(path);

                // determine the potential paths from the tip of the current path
                var lastnode = path[path.length - 1];

                // get the array of cells adjacent to the last node,
                // excluding any adjacent cells that have been visited. 
                // (previously visited cells are in the `path` argument)
                // TODO: a custom Path object could have the adjacency searching
                // as a prototype function
                adjacentcells = adjacencyGraph.get(lastnode).filter(x => !path.includes(x));
                console.log(path + " --> " + adjacentcells);

                // If adjacent nodes are still available and the path has not grown
                // longer than the longest word, add the first of the adjacent cells 
                // to the path and run the search on the new path
                if (adjacentcells.length == 0 || path.length == maxLetterCount) {
                    if (adjacentcells.length == 0) {
                        console.log("No adjacent cells remain");
                    }
                    if (path.length == maxLetterCount) {
                        console.log("Reached max string length of " + maxLetterCount);
                    }
                    return;
                } else {
                    console.log("Searching first adjacent node");
                    var adjacentcell = adjacentcells.shift();
                    newpath = path.slice(0);
                    newpath.push(adjacentcell);
                    console.log(newpath + " --> " + adjacentcells);
                    this.search_deep_path(newpath);
                }

                // 
                $('#found-words').html(this.foundWords.join(","));
                return;

            }

            function getCoordinatesByKey(key) {
                // given a grid cell's key, return its x,y Cartesian location
                // modulo syntax from 
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder
                y = ((key % GRID_HEIGHT) + GRID_HEIGHT) % GRID_HEIGHT;
                x = Math.floor(key / GRID_WIDTH);
                return [x, y]
            }

            function getKeyByCoordinates(x, y) {
                // given an x,y Cartesian location, return the key of the letter
                key = x + (GRID_WIDTH * y)
                return key
            }

            // create a map of index keys to coordinate pairs
            var keyCoordinates = new Map();
            for (var k = 0; k < GRID_WIDTH * GRID_HEIGHT; k++) {
                keyCoordinates.set(k, getCoordinatesByKey(k));
            }


            function getAdjacentCoordinates(rowcol) {
                row = rowcol[0]
                col = rowcol[1]
                nearbypairs = [
                    [col - 1, row - 1],
                    [col, row - 1],
                    [col + 1, row - 1],
                    [col - 1, row],
                    [col + 1, row],
                    [col - 1, row + 1],
                    [col, row + 1],
                    [col + 1, row + 1]
                ]
                gridpairs = Array.from(keyCoordinates.values());
                // using two loops is ugly but will do for now
                validpairs = []
                for (let n = 0; n < nearbypairs.length; n++) {
                    for (let g = 0; g < gridpairs.length; g++) {
                        if (
                            JSON.stringify(nearbypairs[n]) === JSON.stringify(gridpairs[g])
                        ) {
                            validpairs.push(nearbypairs[n]);
                        }
                    }
                }
                return validpairs;
            }

            function fillGrid() {
                // turn the array of letters into a series of rows
                displayLetters = "";

                for (var k = 0; k < GRID_WIDTH * GRID_HEIGHT; k++) {
                    xy = getCoordinatesByKey(letters, k)
                }

                for (var r = 0; r < GRID_HEIGHT; r++) {
                    displayLetters = displayLetters + letters.slice(r * GRID_WIDTH, r * GRID_WIDTH + GRID_WIDTH)
                        .join("") + "\n";
                }
                return displayLetters;
            }

            function buildAdjacency() {
                // for each key in the array, identify 
                // which other keys it can be adjacent to
                var graph = new Map();
                // iterate through the keys, assigning adjacent keys
                for (var k = 0; k < GRID_WIDTH * GRID_HEIGHT; k++) {
                    kxy = keyCoordinates.get(k);
                    var adjacentcoords = getAdjacentCoordinates(kxy);
                    var adjacentkeys = adjacentcoords.map((pair) => getKeyByCoordinates(pair[0], pair[1]))
                    graph.set(k, adjacentkeys);
                }
                return graph;
            }

            // build the adjacency graph on page load, not on click
            const adjacencyGraph = buildAdjacency();
            console.log("adjacencyGraph:");
            console.log(adjacencyGraph);

            letterGrid = new LetterGrid();
            var letters = letterGrid.letters;
            var grid = fillGrid();
            $('#lettergrid').html(grid);
            letterlist = letterGrid.cells_to_string([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
            // rendering the grid to the console:
            for (var l = 0; l < GRID_HEIGHT; l++) {
                console.log(letterlist.slice(l * GRID_HEIGHT, l * GRID_HEIGHT + GRID_WIDTH))
            }

            $('#shuffle').click(function () {
                letterGrid = new LetterGrid();

                letters = letterGrid.letters;
                console.log("shuffled:");
                console.log(letters);
                var grid = fillGrid();
                $('#lettergrid').html(grid);
            });

            $('#search').click(function () {
                letterGrid.foundWords = [];
                $('#found-words').html("");
                for (entry of adjacencyGraph.entries()) {
                    console.log(entry);
                    //letterGrid.search_deep_path([entry[0],])
                    dfs(entry[0])
                }

            });




        });
</script>
</head>

<body>
    <main role="main" class="container">
        <div class="starter-template"></div>

        <h1>Boggletron 3000</h1>
        <div class="row mb-3">
            <div class="col-2">
                <div class="row">
                    <button id="shuffle" class="lead">Shuffle</button>
                    <textarea id="lettergrid"></textarea>
                </div>
            </div>
            <div class="col-2">
                <div class="row">
                    <button id="search" class="lead">Search</button>
                    <textarea id="wordbox"></textarea>
                </div>

            </div>
            <div class="col-4">
                <div class="row">
                    <h3>Found Words:</h3>
                    <p id="found-words">

                    </p>
                </div>
            </div>

        </div>
        </div>
    </main>

</body>

</html>